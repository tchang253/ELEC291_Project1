<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Reflow Oven Control Dashboard</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --bg:#0b0f14;
      --panel:#121826;
      --border:#263042;
      --text:#e6edf3;
      --muted:#9aa7b2;
      --ok:#7ee787;
      --okBorder:#9af2b4;
      --err:#ff7b72;
      --abort:#ff4d4d;
      --abortBorder:#ff8080;

      /* ADDED: dialog colors */
      --warn:#f7d154;
      --warnBorder:#ffe08a;
    }

    body { background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, sans-serif; margin: 24px; }
    h2 { margin-top: 0; }

    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:14px; }
    .row.top { flex-wrap: nowrap; align-items: stretch; }

    .card {
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
    }

    .big { font-size: 24px; font-weight: 700; }
    .muted { color:var(--muted); }

    .kpi { min-width: 170px; width: 170px; white-space: nowrap; }
    .kpi-wide { min-width: 220px; width: 220px; white-space: nowrap; }
    .kpi-temp { min-width: 210px; width: 210px; white-space: nowrap; }

    .num {
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      display: inline-block;
      text-align: right;
    }
    .num.temp { min-width: 64px; }
    .num.set  { min-width: 64px; }
    .num.pwm  { min-width: 48px; }
    .num.time { min-width: 52px; }

    button {
      background:var(--panel);
      color:var(--text);
      padding:14px 18px;
      border-radius:14px;
      border:1px solid var(--border);
      cursor:pointer;
      font-weight:700;
      letter-spacing:0.2px;
    }
    button:hover { filter: brightness(1.15); }
    button:active { transform: translateY(1px); }

    .btn-start { border-color: var(--okBorder); }
    .btn-start.armed {
      background: rgba(126,231,135,0.18);
      border-color: var(--okBorder);
      color: var(--ok);
      box-shadow: 0 0 0 2px rgba(126,231,135,0.18) inset;
    }
    .btn-start.armed:hover { filter:none; background: rgba(126,231,135,0.22); }

    .btn-abort { border-color: var(--abortBorder); }
    .btn-abort.armed {
      background: rgba(255,77,77,0.18);
      border-color: var(--abortBorder);
      color: var(--abort);
      box-shadow: 0 0 0 2px rgba(255,77,77,0.18) inset;
    }
    .btn-abort.armed:hover { filter:none; background: rgba(255,77,77,0.22); }

    input[type="text"]{
      background:var(--panel);
      color:var(--text);
      padding:12px 14px;
      border-radius:12px;
      border:1px solid var(--border);
      width:180px;
      outline:none;
      font-weight:600;
    }

    .badge{
      display:inline-block;
      padding:2px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      font-weight:700;
      white-space: nowrap;
      min-width: 128px;
      text-align: center;
    }
    .badge.ok { color: var(--ok); }
    .badge.err { color: var(--err); }

    .chart-card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      height: 560px;
    }

    .scroll-wrap{
      display:flex;
      gap:12px;
      align-items:center;
      margin-top:10px;
    }

    input[type="range"]{
      width: 100%;
      accent-color: #9aa7b2;
    }

    .controls-row { align-items: flex-end; }
    .spacer-left { width: 404px; }
    .spacer-right { flex: 1; }
    .dialog-span { width: 402px; }

    .dialog {
      height: 44px;
      display:flex;
      align-items:center;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
    }

    /* ADDED: dialog states */
    .dialog.ok {
      background: rgba(126,231,135,0.18);
      border-color: var(--okBorder);
      color: var(--ok);
      box-shadow: 0 0 0 2px rgba(126,231,135,0.18) inset;
    }
    .dialog.warn {
      background: rgba(247,209,84,0.16);
      border-color: var(--warnBorder);
      color: var(--warn);
      box-shadow: 0 0 0 2px rgba(247,209,84,0.14) inset;
    }
    .dialog.crit {
      background: rgba(255,77,77,0.18);
      border-color: var(--abortBorder);
      color: var(--abort);
      box-shadow: 0 0 0 2px rgba(255,77,77,0.18) inset;
    }
  </style>
</head>

<body>
  <h2>Reflow Oven Control Dashboard</h2>

  <div class="row top">
    <div class="card big kpi-temp">
      Temp: <span id="temp" class="num temp">--</span> °C
    </div>

    <div class="card kpi">
      Target: <b><span id="set" class="num set">--</span><span id="setUnit"> °C</span></b>
    </div>

    <div class="card kpi-wide">
      Status:
      <span id="statusBadge" class="badge err"><span id="statusText">DISCONNECTED</span></span>
    </div>

    <div class="card kpi">
      On time: <b><span id="onTime" class="num time">0:00</span></b>
    </div>

    <div class="card kpi">
      State: <b><span id="phase">--</span></b>
    </div>

    <div class="card kpi">
      PWM: <b><span id="pwm" class="num pwm">--</span>%</b>
    </div>

    <div class="card muted kpi-wide" id="netStatus">Polling…</div>
  </div>

  <div class="row controls-row">
    <button id="startBtn" class="btn-start" onclick="doStart()">START</button>
    <button id="liveBtn" onclick="goLive()">Live</button>
    <button id="abortBtn" class="btn-abort" onclick="doAbort()">ABORT</button>

    <div class="spacer-left"></div>
    <div id="dialog" class="card dialog dialog-span"></div>
    <div class="spacer-right"></div>
  </div>

  <div class="chart-card">
    <canvas id="chart"></canvas>

    <div class="scroll-wrap">
      <input id="timeScroll" type="range" min="0" max="0" step="1" value="0">
    </div>
  </div>

  <script>
    // ===== UI =====
    const tempEl = document.getElementById("temp");
    const setEl  = document.getElementById("set");
    const setUnitEl = document.getElementById("setUnit");
    const phaseEl= document.getElementById("phase");
    const pwmEl  = document.getElementById("pwm");
    const onTimeEl = document.getElementById("onTime");

    const netStatusEl = document.getElementById("netStatus");
    const statusTextEl = document.getElementById("statusText");
    const statusBadgeEl = document.getElementById("statusBadge");

    const dialogEl = document.getElementById("dialog");
    let dialogTimer = null;

    /* ===== CHANGED: sticky CRITICAL support (until IDLE AND temp <= 60) ===== */
    let dialogStickyCrit = false;

    function clearDialog() {
      dialogEl.textContent = "";
      dialogEl.classList.remove("ok","warn","crit");
      dialogStickyCrit = false;
      if (dialogTimer) { clearTimeout(dialogTimer); dialogTimer = null; }

      /* ADDED: when CRITICAL clears, ABORT should no longer look "armed" */
      //setAbortArmed(false);
    }

    // ADDED: dialog helper (color-coded)
    function showDialog(msg, level) {
      /* ADDED: if CRITICAL is sticky, ignore non-critical updates */
      if (dialogStickyCrit && level !== "crit") return;

      dialogEl.textContent = msg;

      // clear classes then add requested one
      dialogEl.classList.remove("ok","warn","crit");
      if (level === "ok") dialogEl.classList.add("ok");
      else if (level === "warn") dialogEl.classList.add("warn");
      else if (level === "crit") dialogEl.classList.add("crit");

      // CHANGED: CRITICAL is sticky (no timer)
      if (dialogTimer) { clearTimeout(dialogTimer); dialogTimer = null; }
      if (level === "crit") {
        dialogStickyCrit = true;
        return;
      }

      dialogStickyCrit = false;
      dialogTimer = setTimeout(() => {
        dialogEl.textContent = "";
        dialogEl.classList.remove("ok","warn","crit");
        dialogTimer = null;
      }, 3000);
    }
    /* ===== END CHANGED ===== */

    const slider = document.getElementById("timeScroll");
    const liveBtn = document.getElementById("liveBtn");
    const abortBtn = document.getElementById("abortBtn");
    const startBtn = document.getElementById("startBtn"); /* ADDED */

    function setConnectedUI(connected, label) {
      statusTextEl.textContent = label;
      statusBadgeEl.className = connected ? "badge ok" : "badge err";
    }

    // ===== Settings =====
    const POLL_MS = 250;
    const VIEW_WINDOW_S = 120;

    const Y_MIN = 20;
    const Y_MAX = 275;
    const Y_STEP = 25;

    const history = { temp: [] };
    let followLive = true;

    function updateLiveButton() {
      liveBtn.textContent = followLive ? "Live" : "Live (resume)";
    }

    let lastSeq = -1;
    let tZero = null;

    // --- Run timer (On time) state ---
    let runActive = false;
    let runStartBackendT = null;
    let runFrozenSeconds = 0;
    let lastBackendT = 0;

    let connectedPrev = false;

    let lastPhaseStr = "--";
    let lastTempC = null;
    let prevPhaseStr = "--";

    function fmtMMSS(seconds) {
      const s = Math.max(0, Math.floor(seconds));
      const m = Math.floor(s / 60);
      const r = s % 60;
      return `${m}:${String(r).padStart(2,"0")}`;
    }

    let abortArmed = false;
    function setAbortArmed(armed) {
      abortArmed = armed;
      abortBtn.classList.toggle("armed", armed);
    }

    let startArmed = false;
    function setStartArmed(armed) {
      startArmed = armed;
      startBtn.classList.toggle("armed", armed);
    }

    // ===== Chart.js =====
    const ctx = document.getElementById("chart").getContext("2d");
    const chart = new Chart(ctx, {
      type: "line",
      data: {
        datasets: [
          { label: "Temp (°C)", data: [], spanGaps: false }
        ]
      },
      options: {
        animation: false,
        parsing: false,
        responsive: true,
        maintainAspectRatio: false,
        elements: {
          point: { radius: 0 },
          line: { tension: 0.15 }
        },
        scales: {
          x: {
            type: "linear",
            title: { display: true, text: "Time (s)", color: "#e6edf3" },
            ticks: { color: "#9aa7b2", maxTicksLimit: 8 },
            grid: { color: "rgba(154,167,178,0.15)" },
            min: 0,
            max: VIEW_WINDOW_S
          },
          y: {
            min: Y_MIN,
            max: Y_MAX,
            title: { display: true, text: "Temperature (°C)", color: "#e6edf3" },
            ticks: { color: "#9aa7b2", stepSize: Y_STEP },
            grid: { color: "rgba(154,167,178,0.15)" }
          }
        },
        plugins: {
          legend: { labels: { color: "#e6edf3" } }
        }
      }
    });

    function setSliderMax(endT) {
      const endInt = Math.max(0, Math.floor(endT));
      slider.max = String(endInt);
      if (followLive) slider.value = String(endInt);
    }

    function updateView(endT) {
      const end = Math.max(0, endT);
      const start = (end <= VIEW_WINDOW_S) ? 0 : (end - VIEW_WINDOW_S);
      const shownEnd = (end <= VIEW_WINDOW_S) ? VIEW_WINDOW_S : end;

      chart.options.scales.x.min = start;
      chart.options.scales.x.max = shownEnd;

      chart.data.datasets[0].data = history.temp.filter(p => p.x >= start && p.x <= shownEnd);

      chart.update();
    }

    slider.addEventListener("input", (e) => {
      const endT = Number(e.target.value);
      followLive = (e.target.value === e.target.max);
      updateLiveButton();
      updateView(endT);
    });

    function goLive() {
      followLive = true;
      updateLiveButton();
      slider.value = slider.max;
      updateView(Number(slider.value));
      netStatusEl.textContent = "Following live";
    }

    // ===== Commands =====
    async function postCmd(url, body) {
      try {
        const r = await fetch(url, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: body ? JSON.stringify(body) : null
        });
        const j = await r.json();

        // only show errors here
        if (!j.ok) showDialog("ERROR: " + (j.err ?? ""), "crit");
        return !!j.ok;
      } catch {
        showDialog("Command error", "crit");
        return false;
      }
    }

    async function sendSet() {
      const v = parseFloat(document.getElementById("setInput").value);
      if (Number.isNaN(v)) { showDialog("Bad set value", "warn"); return; }
      await postCmd("/api/set", {set: v});
    }

    async function doStart() {
      /* ADDED: if CRITICAL is sticky, ignore START attempts */
      if (dialogStickyCrit) return;

      if (lastPhaseStr === "COOLING") {
        showDialog("Warning: please wait until the temp is ≤ 60 °C.", "warn");
        return;
      }
      if (lastPhaseStr !== "IDLE") {
        showDialog("Warning: cycle in progress, please wait.", "warn");
        return;
      }
      if (lastTempC != null && Number(lastTempC) > 60) {
        showDialog("Warning: please wait until the temp is ≤ 60 °C.", "warn");
        return;
      }

      const ok = await postCmd("/api/start");
      if (ok) {
        setStartArmed(true);
        setAbortArmed(false);

        runActive = true;
        runStartBackendT = null;
        runFrozenSeconds = 0;
        onTimeEl.textContent = "0:00";

        // GREEN dialog on successful start
        showDialog("Success: cycle initiated, transitioning to PREHEAT.", "ok");
      }
    }

    async function doAbort() {
      const ok = await postCmd("/api/abort");
      if (ok) {
        setAbortArmed(true);
        setStartArmed(false);

        if (runActive) {
          if (runStartBackendT == null) runFrozenSeconds = 0;
          else runFrozenSeconds = Math.max(0, lastBackendT - runStartBackendT);
        }
        runActive = false;
        runStartBackendT = null;

        onTimeEl.textContent = fmtMMSS(runFrozenSeconds);

        // RED dialog on abort (STICKY until IDLE AND temp <= 60)
        showDialog("CRITICAL: cycle aborted, heating disabled.", "crit");
      }
    }

    // ===== Polling =====
    async function poll() {
      try {
        const r = await fetch("/api/latest", { cache: "no-store" });
        if (!r.ok) throw new Error("HTTP " + r.status);
        const m = await r.json();

        lastBackendT = Number(m.t ?? 0);

        const connected = (m.connected === true) || (m.status === "CONNECTED");
        const statusLabel = m.status ?? (connected ? "CONNECTED" : "DISCONNECTED");
        setConnectedUI(connected, statusLabel);

        if (!connected) {
          runActive = false;
          runStartBackendT = null;
          runFrozenSeconds = 0;
          onTimeEl.textContent = "0:00";
          setAbortArmed(false);
          setStartArmed(false);

          /* CHANGED */
          clearDialog();
        } else {
          if (runActive) {
            if (runStartBackendT === null) runStartBackendT = lastBackendT;
            const elapsed = Math.max(0, lastBackendT - runStartBackendT);
            onTimeEl.textContent = fmtMMSS(elapsed);
          } else {
            onTimeEl.textContent = fmtMMSS(runFrozenSeconds);
          }
        }
        connectedPrev = connected;

        tempEl.textContent  = (m.temp == null) ? "--" : Number(m.temp).toFixed(1);

        const phaseStr = (m.phase ?? "--");
        phaseEl.textContent = phaseStr;

        lastPhaseStr = phaseStr;
        lastTempC = (m.temp == null) ? null : Number(m.temp);

        /* CHANGED: mirror Discord-triggered START/ABORT by reacting to PHASE transitions */

        // External START shows up as IDLE -> PREHEAT
        if (prevPhaseStr === "IDLE" && phaseStr === "PREHEAT") {
          setStartArmed(true);
          setAbortArmed(false);

          runActive = true;
          runStartBackendT = null;
          runFrozenSeconds = 0;
          onTimeEl.textContent = "0:00";

          showDialog("Success: cycle initiated, transitioning to PREHEAT.", "ok");
        }

        /* NEW: any deviation from expected phase path triggers UI-only ABORT */
        function isExpectedTransition(prevP, nextP) {
          if (prevP === nextP) return true; // staying in same state is fine

          // expected "golden path"
          if (prevP === "IDLE"    && nextP === "PREHEAT") return true;
          if (prevP === "PREHEAT" && nextP === "SOAK")    return true;
          if (prevP === "SOAK"    && nextP === "RAMP")    return true;
          if (prevP === "RAMP"    && nextP === "REFLOW")  return true;
          if (prevP === "REFLOW"  && nextP === "COOLING") return true;
          if (prevP === "COOLING" && nextP === "IDLE")    return true;

          return false;
        }

        // Only evaluate deviations once we are "in a run" (i.e., not starting from unknown)
        // Here: if we've ever seen a PREHEAT at least once this session, we treat deviations as abort-worthy.
        // Minimal: we just check whenever prevPhaseStr is known and not "--".
        if (prevPhaseStr !== "--" && phaseStr !== "--") {
          const okTransition = isExpectedTransition(prevPhaseStr, phaseStr);

          // If it's not an expected transition, trigger UI-only abort
          if (!okTransition) {
            setAbortArmed(true);
            setStartArmed(false);

            if (runActive) {
              if (runStartBackendT == null) runFrozenSeconds = 0;
              else runFrozenSeconds = Math.max(0, lastBackendT - runStartBackendT);
            }
            runActive = false;
            runStartBackendT = null;

            onTimeEl.textContent = fmtMMSS(runFrozenSeconds);

            showDialog("CRITICAL: cycle aborted, heating disabled", "crit");
          }
        }

        /* ADDED: clear sticky CRITICAL ONLY when IDLE AND temp <= 60 */
        if (dialogStickyCrit && phaseStr === "IDLE" && lastTempC != null && Number(lastTempC) <= 60) {
          clearDialog();
          setAbortArmed(false);
        }

        const hideTarget = (phaseStr === "IDLE" || phaseStr === "COOLING");
        if (hideTarget) {
          setEl.textContent = "";
          setUnitEl.textContent = "";
        } else {
          setEl.textContent   = (m.set  == null) ? "--" : Number(m.set).toFixed(1);
          setUnitEl.textContent = " °C";
        }

        pwmEl.textContent   = (m.pwm   ?? "--");

        if (prevPhaseStr === "COOLING" && phaseStr === "IDLE" && m.temp != null && Number(m.temp) <= 60) {
          setStartArmed(false);
        }

        prevPhaseStr = phaseStr;

        if (m.seq == null) {
          netStatusEl.textContent = "Backend missing seq";
          return;
        }
        if (m.seq === lastSeq) {
          const endT = followLive ? Number(slider.max) : Number(slider.value);
          updateView(endT);
          return;
        }
        lastSeq = m.seq;

        if (tZero === null) {
          tZero = Number(m.t);
        }

        const t = Number(m.t) - tZero;

        history.temp.push({ x: t, y: (m.temp == null ? null : Number(m.temp)) });

        setSliderMax(t);

        const endT = followLive ? Number(slider.max) : Number(slider.value);
        updateView(endT);

        netStatusEl.textContent = followLive ? "Live (auto-follow)" : "Viewing history";
      } catch {
        netStatusEl.textContent = "Poll error";
        setConnectedUI(false, "DISCONNECTED");

        runActive = false;
        runStartBackendT = null;
        runFrozenSeconds = 0;
        onTimeEl.textContent = "0:00";

        connectedPrev = false;
        setAbortArmed(false);
        setStartArmed(false);

        /* CHANGED */
        clearDialog();
      }
    }

    updateLiveButton();
    setInterval(poll, POLL_MS);
  </script>
</body>
</html>